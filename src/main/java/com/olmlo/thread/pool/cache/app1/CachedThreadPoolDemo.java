package com.olmlo.thread.pool.cache.app1;

import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * Main class of the example. Create three FileSearch objects, encapsulate inside three Task objects and execute them as
 * they were callable objects
 *
 */
public class CachedThreadPoolDemo {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// Create a new Executor
		ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();

		// Create three FileSearch objects
		FileSearch system = new FileSearch("C:\\Windows", "log");
		FileSearch apps = new FileSearch("C:\\Program Files", "log");
		FileSearch documents = new FileSearch("C:\\Documents And Settings", "log");

		// Create three Task objects
		SearchFuture systemTask = new SearchFuture(system, null);
		SearchFuture appsTask = new SearchFuture(apps, null);
		SearchFuture documentsTask = new SearchFuture(documents, null);

		// Submit the Tasks to the Executor
		executor.submit(systemTask);
		executor.submit(appsTask);
		executor.submit(documentsTask);

		// Shutdown the executor and wait for the end of the tasks
		executor.shutdown();
		try {
			executor.awaitTermination(1, TimeUnit.DAYS);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		// Write to the console the number of results
		try {
			System.out.printf("Main: System Task: Number of Results:    %d\n", systemTask.get().size());
			System.out.printf("Main: App Task: Number of Results:       %d\n", appsTask.get().size());
			System.out.printf("Main: Documents Task: Number of Results: %d\n", documentsTask.get().size());
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (ExecutionException e) {
			e.printStackTrace();
		}
	}
}

class SearchFuture extends FutureTask<List<String>> {

	private FileSearch fileSearch;

	/**
	 * Constructor of the class
	 * 
	 * @param runnable
	 *            FileSearh object that is going to execute
	 * @param result
	 *            Object to return as result. We are going to ignore this structure
	 */
	public SearchFuture(Runnable runnable, List<String> result) {
		super(runnable, result);
		this.fileSearch = (FileSearch) runnable;
	}

	/**
	 * Override the set method. As we are going to execute a Runnable object, this method establish the null value as
	 * result. We change this behavior returning the result list generated by the FileSearch task
	 */
	protected void set(List<String> v) {
		if (v == null) {
			v = fileSearch.getResults();
		}
		super.set(v);
	}
}
